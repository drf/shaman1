Let's use this file to define plugins design.

First of all, we'll need some different sets of plugins:

 - Backend (for package management)
 - GUI (for GUI-related stuff)
 - Data (for handling processes, such as ABS, AUR or makepkg handling)
 - Configuration Plugins (if really needed) (Not needed, since every plugin can have its own configuration-widget)

Every plugin will have a set of dependancies on another plugin. So, this will be our base class structure.

ShamanAbstractPlugin
 |
 |
 ---> ShamanCorePlugin
 |
 ---> ShamanDataPlugin
...

So AbstractPlugin will take care of initialization: it will contain about data, such as name and blabla, plugin type, so Backend/Data/GUI... and Dependencies on other Plugins.

Next we have all different plugins. So to load a plugin we cast it to a ShamanAbstractPlugin*, check its type and then finally cast it to the right plugin type. Seems pretty a clean approach to me. 

Comment from Lukas: We probably shouldn't cast, just initialize them, for what do we need to load them?

For ShamanGUIPlugin:
We need a function to access each part of the GUI, for example:
addDockWidget(QDockWidget *widget, orientation);
addToolBarAction(QAction *action);

POINT 1: "We should only have one "Package-Manager"-Plugin loaded. How to handle that?"
   -Lukas: no idea ;) Dependency and Conflict tree?
   -Lukas: Conflict is bad idea, better handle that from source, so only one data-plugin loaded...


Loading and selecting of Plugins:
*Use KPluginSelector
*Probably extend it?